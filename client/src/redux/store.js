import { configureStore, createSlice, current } from '@reduxjs/toolkit';
import {
	createArrayBufferWithMetadata,
	createChunks,
	reconstructFileAndDownload,
} from '../utils/files';
import configs from '../configs';

const metadataSlice = createSlice({
	name: 'metadata',
	initialState: {
		ownType: null,
		receiverIds: [],
	},
	reducers: {
		setOwnType: (state, action) => {
			const { type } = action.payload;
			if (type == 'SENDER' || type == 'RECEIVER') {
				state.ownType = type;
			}
		},
		addReceiverId: (state, action) => {
			const { receiverId } = action.payload;
			const currentReceiverIds = state.receiver;
			const updatedReceiverIds = [
				...new Set(currentReceiverIds).add(receiverId),
			];
			state.receiverIds.push(updatedReceiverIds);
		},
	},
});

const fileSlice = createSlice({
	name: 'file',
	initialState: {
		files: [],
	},
	reducers: {
		addFileInRedux: (state, action) => {
			const payload = action?.payload;
			if (payload) {
				const { id, filename, size, content, hasContent } = payload;
				let chunks, totalChunks;
				if (hasContent) {
					const { chunks: c, totalChunks: tc } = createChunks(
						content,
						configs.CHUNK_SIZE
					);
					chunks = c;
					totalChunks = tc;
				} else {
					const { chunks: c, totalChunks: tc } = action.payload;
					chunks = c;
					totalChunks = tc;
				}

				state.files.push({
					id,
					filename,
					size,
					chunks,
					totalChunks,
				});
			}
		},
		removeFileFromRedux: (state, action) => {
			state.files = state.files.filter(
				(file) => file.id !== action.payload
			);
		},
		addChunkInFile: (state, action) => {
			const { fileId, chunk } = action.payload;
			if (fileId < state.files.length) {
				const chunksInRedux = state.files[fileId].chunks;
				const totalChunks = state.files[fileId].totalChunks;
				chunksInRedux.push(chunk);
				if (chunksInRedux.length === totalChunks) {
					const fileName = state.files[fileId].filename;
					reconstructFileAndDownload(chunksInRedux, fileName);
				}
			}
		},
	},
});

const webRTCSlice = createSlice({
	name: 'webRTC',
	initialState: {
		isConnected: false,
	},
	reducers: {
		setIsWebRTCConnected: (state, action) => {
			const { status } = action.payload;
			state.isConnected = status;
		},
	},
});

// Export the actions generated by createSlice
export const { addFileInRedux, removeFileFromRedux, addChunkInFile } =
	fileSlice.actions;

export const { setIsWebRTCConnected } = webRTCSlice.actions;

export const { setOwnType, addReceiverId } = metadataSlice.actions;

export const isWebRTCConnected = (state) => {
	return state.isConnected;
};

export const getFileNames = (state) => {
	return state.file.files.map((file) => file.filename);
};

export const getTotalChunks = (state, id) => {
	const file = getFile(state, id);
	const chunks = file.chunks;
	return chunks.length;
};

export const getFileChunkInArrayBuffer = async (state, id, chunkId) => {
	const file = getFile(state, id);
	const chunk = chunkId < file.chunks.length ? file.chunks[chunkId] : null;
	if (chunk) {
		const chunkArrayBuffer = await createArrayBufferWithMetadata(
			chunk?.chunk,
			id,
			chunkId
		);
		return chunkArrayBuffer;
	} else return null;
};

export const getFile = (state, id) => {
	return state.files.find((file) => file.id === id);
};

export const getFilesMetaData = (state) => {
	return state.files.map((file) => {
		return {
			id: file.id,
			filename: file.filename,
			size: file.size,
			totalChunks: file.chunks.length,
		};
	});
};

// Create the Redux store
const store = configureStore({
	reducer: {
		file: fileSlice.reducer,
		webRTC: webRTCSlice.reducer,
		metadata: metadataSlice.reducer,
	},
});

export default store;
